/*
*	Author: Patrick Walter
*/

#include <stdlib.h>
#include <string.h>

static int num_of_jobs = 0;
static int next_job_id = 1;
static job_node* job_list_head_ptr = NULL;
static job_node* job_list_tail_ptr = NULL;

void traverseJobList (void (*func)(job_node*)) 
{
  	job_node* ptr = job_list_head_ptr;

	while(ptr != NULL)
	{
		func(ptr);
		ptr = ptr->next_node;
	}
}

extern void killAllJobs()
{

}

extern void checkBackgroundProcesses()
{
	job_node* ptr = job_list_head_ptr;

	while(ptr != NULL)
	{
		int status;

		// Check to see if the job is done yet
		if(waitpid(ptr->pid, &status, WNOHANG) > 0)
		{
			job_node* prevptr = ptr->prev_node;
			job_node* nextptr = ptr->next_node;

			// Print out job status
			printf("[%d] %d finished %s\n", ptr->jobID, ptr->pid, ptr->command);
			free(ptr->command);

			// The job is finished so clear it and move on
			if(prevptr != NULL)
			{
				prevptr->next_node = nextptr;
			}
			if(nextptr != NULL)
			{
				nextptr->next_node = prevptr;
			}
			if(ptr == job_list_tail_ptr)
			{
				job_list_tail_ptr = ptr->prev_node;
			}
			if(ptr == job_list_head_ptr)
			{
				job_list_head_ptr = ptr->next_node;
			}
			free(ptr);
			ptr = nextptr;
		}
		else
		{
			ptr = ptr->next_node;
		}
	}
}

// Creates a new node inserts it into the list of jobs
/* 
*	@param a_pid should be the child process ID
* 	@param a_cmd pointer to a command string
*
*	@return -1 if there was an error
*			else jobID
*/
extern int addJob(pid_t a_pid, char* a_cmd)
{
	job_node* new_node = malloc(sizeof(*new_node));
	if(!new_node)
	{
		printf("\nerror creating new node: %d, command: \"%s\"", a_pid, a_cmd);
		return -1;
	}

	new_node->jobID = next_job_id;
	next_job_id++; //update the next job ID
	new_node->pid = a_pid;
	new_node->command = malloc (sizeof (*(new_node->command)) * (strlen (a_cmd) + 1));
	
	if(!new_node->command)
	{
		next_job_id--;
		printf("\nerror creating command for pid: %d, command: \"%s\", jobPid: %d\n", a_pid, a_cmd, next_job_id);
		return -1;
	}
	strcpy(new_node->command, a_cmd);

	job_node* temp;
	if(job_list_head_ptr == NULL)
	{
		job_list_head_ptr = new_node;
		job_list_head_ptr->prev_node = NULL;
		job_list_head_ptr->next_node = NULL;
		job_list_tail_ptr = new_node;
	}
	else
	{
		job_list_tail_ptr = job_list_head_ptr;
		while(job_list_tail_ptr != NULL)
		{	
			temp = job_list_tail_ptr;
			job_list_tail_ptr = job_list_tail_ptr->next_node;
		}
		job_list_tail_ptr = new_node;
		temp->next_node = job_list_tail_ptr;
		job_list_tail_ptr->prev_node = temp;
		job_list_tail_ptr->next_node = NULL;
	}
	num_of_jobs++;
	return new_node->jobID;
}

/*
*	Finds a node to be removed. Note that this
*	does not actually delete the memory, it 
*	simply
*
*	@param a_pid process id generated by the OS
*	@return pointer to the node that was removed
*			NULL if the node was not found
*
*	NOTE: It is up to the caller to deal with freeing
*			up the memory of the returned node
*/
extern job_node* removeJobByPID(pid_t a_pid)
{
	//TODO remember to handle job id decrement
	job_node* ptr = NULL;
	job_node* node_to_return = NULL;

	ptr = job_list_head_ptr;

	while(ptr != NULL)
	{
		if(ptr->pid == a_pid)
		{
			job_node* prev = ptr->prev_node;
			job_node* next = ptr->next_node;
			node_to_return = ptr;

			if(prev != NULL)
			{
				// Close the gap on the left of the node
				prev->next_node = next;
			}
			if(next != NULL)
			{
				// Close the gap on the right of the node
				next->prev_node = prev;
			}
			if(ptr == job_list_tail_ptr)
			{
				// Node is at the end
				job_list_tail_ptr = ptr->prev_node;
			}
			if(ptr == job_list_head_ptr)
			{
				// Node is at the beginning
				job_list_head_ptr = ptr->next_node;
			}

			// TODO how to deal with decrementing the jobID?
			num_of_jobs--;
			return node_to_return;
		}
		ptr = ptr->next_node;
	}
	return node_to_return;
}

// Returns the process id of a task given its job id
/*
*	@param a_job_id a custom generated jobID
*	@return -1 if the jobID is not found 
*			else jobID is returned
*/
extern int getJobByJobID(int a_job_id)
{
	job_node* ptr = job_list_head_ptr;
	int process_id = -1;

	while(ptr != NULL)
	{
		if(ptr->jobID == a_job_id)
		{
			process_id = ptr->pid;
			break;
		}
		else
		{
			ptr = ptr->next_node;
		}
	}
	return process_id;
}

void printList(job_node* ptr)
{
	fprintf(stdout, "[%d] %d %s\n", ptr->jobID, ptr->pid, ptr->command);
}

void PrintAllJobs()
{
	traverseJobList(printList);
}

/*
int main()
{
	int job_id_array[10];
	char* commandarray[10] = {"love", "and", "hate", "are", "one", "in", "the", "same", "evil", "demon"};
	int job_pid_array[10] = { 11, 21, 31, 41, 51, 61, 71, 81, 91, 101 };
	commandarray[0] = "love";

	memset(job_id_array, 0, sizeof(job_id_array));

	int indx = 0;
	for(indx = 0; indx < 10; indx++)
	{
		job_id_array[indx] = addJob(job_pid_array[indx], commandarray[indx]);
		printf("Inserting: \"%s\" | Num Jobs: %d, job ID: %d\n", commandarray[indx], num_of_jobs, job_id_array[indx]);
		if(job_list_head_ptr != NULL)
		{
			printf("head: %s\n", job_list_head_ptr->command);
			if(job_list_head_ptr->prev_node != NULL)
			{
				printf("head's previus:: %s\n", job_list_head_ptr->prev_node->command);
			}
		}
		else
		{
			printf("head is null\n");
		}
		if(job_list_tail_ptr != NULL)
		{
			printf("tail: %s\n", job_list_tail_ptr->command);
		}
		else
		{
			printf("tail is null\n");
		}		
	}

	traverseJobList(printList);
	if(removeJobByPID(11) == NULL)
	{
		printf("Node not found\n");
	}
	traverseJobList(printList);
	if(removeJobByPID(91) == NULL)
	{
		printf("Node not found\n");
	}
	traverseJobList(printList);
	if(removeJobByPID(101) == NULL)
	{
		printf("Node not found\n");
	}
	traverseJobList(printList);
	if(removeJobByPID(121) == NULL)
	{
		printf("Node not found\n");
	}
	addJob(109, "hope, Hope in that cup");
	traverseJobList(printList);

	return 0;
}
*/









