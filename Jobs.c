/*
*	Author: Patrick Walter
*/

#include <stdlib.h>
#include <string.h>

#include "Jobs.h"

static int num_of_jobs = 0;
static int next_job_id = 1;
static job_node* job_list_head_ptr = NULL;
static job_node* job_list_tail_ptr = NULL;

void traverseJobList (void (*func)(job_node*)) 
{
  	job_node* ptr = job_list_head_ptr;

	while(ptr != NULL)
	{
		func(ptr);
		ptr = ptr->next_node;
	}
}

extern void killAllJobs()
{
	job_node* ptr = job_list_head_ptr;
	// TODO
}

// Creates a new node inserts it into the list of jobs
/* 
*	@param a_pid should be the child process ID
* 	@param a_cmd pointer to a command string
*
*	@return -1 if there was an error
*			else jobID
*/
extern int addJob(pid_t a_pid, char* a_cmd)
{
	job_node* new_node = malloc(sizeof(*new_node));
	if(!new_node)
	{
		printf("\nerror creating new node: %d, command: \"%s\"", a_pid, a_cmd);
		return -1;
	}

	new_node->jobID = next_job_id;
	next_job_id++; //update the next job ID
	new_node->pid = a_pid;
	new_node->command = malloc (sizeof (*(new_node->command)) * (strlen (a_cmd) + 1));
	
	if(!new_node->command)
	{
		next_job_id--;
		printf("\nerror creating command for pid: %d, command: \"%s\", jobPid: %d\n", a_pid, a_cmd, next_job_id);
		return -1;
	}
	strcpy(new_node->command, a_cmd);

	job_node* temp;
	if(job_list_head_ptr == NULL)
	{
		job_list_head_ptr = new_node;
		job_list_head_ptr->prev_node = NULL;
		job_list_head_ptr->next_node = NULL;
		job_list_tail_ptr = new_node;
	}
	else
	{
		job_list_tail_ptr = job_list_head_ptr;
		while(job_list_tail_ptr != NULL)
		{	
			temp = job_list_tail_ptr;
			job_list_tail_ptr = job_list_tail_ptr->next_node;
		}
		job_list_tail_ptr = new_node;
		temp->next_node = job_list_tail_ptr;
		job_list_tail_ptr->prev_node = temp;
		job_list_tail_ptr->next_node = NULL;
	}

/*
	new_node->next_node = NULL;
	if(!job_list_head_ptr)
	{
		// Inserting on empty list
		job_list_head_ptr = new_node;
	} 
	else
	{
		// Inserting on none-empty list
		new_node->prev_node = job_list_tail_ptr;
	}
	if(job_list_tail_ptr)
	{
		// 
		job_list_tail_ptr->next_node = new_node;
	}
	else
	{
		job_list_tail_ptr = new_node;
	}*/


/*	//List is empty
	if(num_of_jobs == 0)
	{
printf("Inserting head\n");
		job_list_head_ptr = new_node;
		new_node->next_node = NULL;
		new_node->prev_node = job_list_tail_ptr;
		job_list_tail_ptr = new_node;
	}
	else
	{
printf("Inserting at tail\n");
		new_node->next_node = NULL;
		new_node->prev_node = job_list_tail_ptr;
		job_list_tail_ptr = new_node;
	}
*/
	num_of_jobs++;
	return new_node->jobID;
}

// Removes a job from the 
/*
*	@param a_pid process id generated by the OS
*	@return pointer to the node that was removed
*			NULL if the node was not found
*
*	NOTE: It is up to the caller to deal with freeing
*			up the memory of the returned node
*/
extern job_node* removeJobByPID(pid_t a_pid)
{
	//TODO remember to handle job id decrement
	job_node* ptr = NULL;
	job_node* node_to_return = NULL;

	ptr = job_list_head_ptr;

	while(ptr != NULL)
	{
		if(ptr->pid == a_pid)
		{
			job_node* prev = ptr->prev_node;
			job_node* next = ptr->next_node;
			node_to_return = ptr;

			if(prev != NULL)
			{
				// Close the gap on the left of the node
				prev->next_node = next;
			}
			if(next != NULL)
			{
				// Close the gap on the right of the node
				next->prev_node = prev;
			}
			if(ptr == job_list_tail_ptr)
			{
				// Node is at the end
				job_list_tail_ptr = ptr->prev_node;
			}
			if(ptr == job_list_head_ptr)
			{
				// Node is at the beginning
				job_list_head_ptr = ptr->next_node;
			}

			// TODO how to deal with decrementing the jobID?
			num_of_jobs--;
			return node_to_return;
		}
		ptr = ptr->next_node;
	}

/*	while(ptr != NULL)
	{
		// Found the job to be removed
		if(ptr->pid == a_pid)
		{
			node_to_return = ptr;

			if(ptr->prev_node == NULL)
			{
				// Item to delete is the only item
				//free(ptr);
				job_list_head_ptr = NULL;
				job_list_tail_ptr = NULL;
				return node_to_return;
			}
			else
			{
				var->next_node = temp1;
				temp1->prev_node = var;
				//free(ptr);
				return node_to_return;
			}
		}
		else
		{
			var = ptr;
			ptr = ptr->next_node;
			temp1 = ptr->next_node;
		}
	}*/

			/*
			if(ptr == job_list_head_ptr)
			{
				// Removing Head
				job_node* temp_next = ptr->next_node;
				temp_next->prev_node = job_list_tail_ptr;
				job_list_head_ptr =  temp_next;
			} 
			else if(ptr == job_list_tail_ptr)
			{
				// Removing Tail
				job_node* temp = ptr->prev_node;
				job_list_tail_ptr = temp;
				temp->next_node = NULL;
			}
			else
			{
				// Removing somewhere in the middle
				job_node* temp_prev = ptr->prev_node;
				job_node* temp_next = ptr->next_node;
				// Connect the previous node with the next
				temp_prev->next_node = temp_next; 
				// Connect the next node with the previus one
				temp_next->prev_node = temp_prev; 
			}*/
	return node_to_return;
}

// Returns the process id of a task given its job id
/*
*	@param a_job_id a custom generated jobID
*	@return -1 if the jobID is not found 
*			else jobID is returned
*/
extern int getJobByJobID(int a_job_id)
{
	job_node* ptr = job_list_head_ptr;
	int process_id = -1;

	while(ptr != NULL)
	{
		if(ptr->jobID == a_job_id)
		{
			process_id = ptr->pid;
			break;
		}
		else
		{
			ptr = ptr->next_node;
		}
	}
	return process_id;
}

void printList(job_node* ptr)
{
	fprintf(stdout, "[%d] %d command: %s\n", ptr->jobID, ptr->pid, ptr->command);
}

int main()
{
	int job_id_array[10];
	char* commandarray[10] = {"love", "and", "hate", "are", "one", "in", "the", "same", "evil", "demon"};
	int job_pid_array[10] = { 11, 21, 31, 41, 51, 61, 71, 81, 91, 101 };
	commandarray[0] = "love";

	memset(job_id_array, 0, sizeof(job_id_array));

	int indx = 0;
	for(indx = 0; indx < 10; indx++)
	{
		job_id_array[indx] = addJob(job_pid_array[indx], commandarray[indx]);
		printf("Inserting: \"%s\" | Num Jobs: %d, job ID: %d\n", commandarray[indx], num_of_jobs, job_id_array[indx]);
		if(job_list_head_ptr != NULL)
		{
			printf("head: %s\n", job_list_head_ptr->command);
			if(job_list_head_ptr->prev_node != NULL)
			{
				printf("head's previus:: %s\n", job_list_head_ptr->prev_node->command);
			}
		}
		else
		{
			printf("head is null\n");
		}
		if(job_list_tail_ptr != NULL)
		{
			printf("tail: %s\n", job_list_tail_ptr->command);
		}
		else
		{
			printf("tail is null\n");
		}		
	}

	traverseJobList(printList);
	if(removeJobByPID(11) == NULL)
	{
		printf("Node not found\n");
	}
	traverseJobList(printList);
	if(removeJobByPID(91) == NULL)
	{
		printf("Node not found\n");
	}
	traverseJobList(printList);
	if(removeJobByPID(101) == NULL)
	{
		printf("Node not found\n");
	}
	traverseJobList(printList);
	if(removeJobByPID(121) == NULL)
	{
		printf("Node not found\n");
	}
	addJob(109, "hope, Hope in that cup");
	traverseJobList(printList);

	return 0;
}









